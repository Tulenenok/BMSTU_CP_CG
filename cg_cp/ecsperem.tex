\chapter{Исследовательская часть}

В данном разделе были приведены примеры работы программ, постановка эксперимента и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование, следующие:

\begin{itemize}
	\item Операционная система Ubuntu 22.04.1 \cite{ubuntu} Linux x86\_64.
	\item Память 8 ГБ.
	\item Процессор AMD® Ryzen 5 3500u.
\end{itemize}

Тестирование проводилось на ноутбуке, включенном в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также непосредственно системой тестирования.

\section{Время выполнения алгоритмов}

Для замера процессорного времени использовалась функция
$std::chrono::system\_clock::now(...)$ из библиотеки $chrono$ языка программи-
рования $C++$. Функция возвращает процессорное время типа $float$ в секун-
дах.

Замеры времени для каждой длины входного массива треугольников проводились 1000 раз. В качестве результата взято среднее время работы алгоритма на данной длине слова. При каждом запуске алгоритма, на вход подавались случайно сгенерированные массивы треугольников. Тестовые пакеты создавались до начала замера времени.

\subsection{Время выполнения однопоточной реализации}

Результаты замеров приведены в таблице \ref{tbl:best}.

Обозначения: ОВ --- однопоточное выполнение (C/C++), ПВ - последовательное выполнение (C/C++), МВ - многопроцессное выполнение (Python), КТ - количество треугольников.

\begin{table}[h]
	\begin{center}
		\captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tbl:best}Результаты замеров времени ОВ, ПВ, МВ для разных КТ (в микросекундах).}
		\begin{tabular}{|l|l|l|l|}
			
			\hline
			КТ&ОВ&ПВ&МВ\\
			\hline
			10 & 30 & 28 & 1832 \\
			\hline
			20 & 35 & 31 & 2798 \\
			\hline
			30 & 40 & 36 & 5125 \\
			\hline
			50 & 43 & 39 & 9782 \\
			\hline
			100 & 57 & 49 & 24320 \\
			\hline
			200 & 75 & 69 & 56680 \\
			\hline
			
		\end{tabular}
	\end{center}
\end{table}

\subsection{Время выполнения многопоточной реализации}

Данное исследование проводилось вокруг реализации на ЯП C/C++, так как ЯП Python3 не поддерживает нативные потоки.

Результаты замеров приведены в таблице \ref{tbl:wor}.

\captionsetup{justification=raggedright,singlelinecheck=false}
\begin{table}[h]
	\begin{center}
		\caption{\label{tbl:wor} Время выполнения программы, реализующей многопоточный алгоритм удаления невидимых граней, использующий Z-буфер, для разного количества потоков (в микросекундах).}
		\begin{tabular}{|c|c|c|c|c|c|c|}
			\hline				
			\multirow{3}{*}{\makecell{Количество\\ треугольников\\ }} & 	\multicolumn{6}{c|}{Количество потоков} \\ [3ex]
			\cline{2-7}		
			&1&	4&	6&	12&	24& 48\\
			\hline		
			10&	    30&	27&	33&	34&	41&	47\\
			\hline		
			100&	57&	75&	76&	76&	81&	88\\
			\hline		
			1000&	245& 143& 118& 121&	133& 178\\
			\hline		
			10000&	2098& 845& 688&	788& 822& 999\\
			\hline		
			100000&	19935&	5606&	5231&	6300& 7653& 9923\\
			\hline			
			
		\end{tabular}
	\end{center}
\end{table}

\newpage


При 6 потоках достигается пик, при котором все логические ядра
процессора одновременно выполняют параллельные ветки алгоритма. Далее
при увеличении числа потоков производительность падает. Это объясняет-
ся тем, что создается очередь потоков, которая замедляет работу програм-
мы.

\section*{Вывод}

В данном разделе было произведено сравнение времени выполнения
реализации алгоритма удаления невидимых ребер, при последовательной реализации и многопоточной. Результат показал, что выгоднее всего по времени использовать столько потоков, сколько у процессора логических ядер.

